[{"content":"Object Mapping with Mapster Object mapping is the process of transferring properties from one object to another, commonly used in modular or layered applications. This approach is particularly valuable in systems with clean architecture or domain-driven design, allowing seamless data transfer between modules or mapping request objects to data models, commands, or database entities.\nWe will explore object mapping using the Mapster library in C#, a fast and flexible alternative to other mapping libraries like AutoMapper.\nInstallation To add Mapster to your project, run:\ndotnet add package Mapster Basic Mapping with Adapt With Mapster, we can replace manual mapping code with a single Adapt method, which automatically maps properties by matching names between source and destination objects.\nusing Mapster; var user = UserGenerator.GenerateRandom(); var userResponse = user.Adapt\u0026lt;UserResponse\u0026gt;(); Console.WriteLine(user); Console.WriteLine(userResponse); Models Define User and UserResponse records to be mapped:\nnamespace MapsterPlayground.Entities { public record User( int Id, string FirstName, string LastName ); } namespace MapsterPlayground.Contracts { public record UserResponse( int Id, string FirstName, string LastName ); } Configuring Custom Mappings with TypeAdapterConfig In cases where properties don’t match by name, we can create custom mapping configurations. For example, if UserResponse has a FullName property that combines FirstName and LastName from User, we can specify this in a custom configuration.\nvar config = new TypeAdapterConfig(); config.NewConfig\u0026lt;User, UserResponse\u0026gt;() .Map(dest =\u0026gt; dest.FullName, src =\u0026gt; $\u0026#34;{src.FirstName} {src.LastName}\u0026#34;); var userResponse = user.Adapt\u0026lt;UserResponse\u0026gt;(config); Console.WriteLine(user); Console.WriteLine(userResponse); Updated UserResponse Model namespace MapsterPlayground.Contracts { public record UserResponse( int Id, string FullName ); } Ignoring Unmapped Properties Use IgnoreNonMapped to ignore properties in the destination that do not have corresponding mapped properties in the source.\nconfig.NewConfig\u0026lt;User, UserResponse\u0026gt;() .Map(dest =\u0026gt; dest.FullName, src =\u0026gt; $\u0026#34;{src.FirstName} {src.LastName}\u0026#34;) .IgnoreNonMapped(true); Global Configuration with TypeAdapterConfig.GlobalSettings Mapster supports global configuration settings, allowing you to avoid passing custom configurations for each mapping instance.\nvar config = TypeAdapterConfig.GlobalSettings; config.NewConfig\u0026lt;User, UserResponse\u0026gt;() .Map(dest =\u0026gt; dest.FullName, src =\u0026gt; $\u0026#34;{src.FirstName} {src.LastName}\u0026#34;); var userResponse = user.Adapt\u0026lt;UserResponse\u0026gt;(); Difference Between NewConfig and ForType NewConfig creates a fresh configuration for a mapping, overriding any previous settings for that pair (e.g., User to UserResponse). This can replace existing mappings, potentially losing previously defined rules.\nIn contrast, ForType appends new rules to an existing configuration, preserving prior mappings. Use ForType to add additional mappings without discarding previous ones.\nCombining Multiple Mapping Rules Mapster allows defining multiple rules. For example, we can add a rule to adjust the Id property.\nTypeAdapterConfig\u0026lt;User, UserResponse\u0026gt;.NewConfig() .Map(dest =\u0026gt; dest.FullName, src =\u0026gt; $\u0026#34;{src.FirstName} {src.LastName}\u0026#34;); config.ForType\u0026lt;User, UserResponse\u0026gt;() .Map(dest =\u0026gt; dest.Id, src =\u0026gt; src.Id + 1); Conditional Mapping Mapster supports conditional mapping. For instance, only map FullName if FirstName starts with the letter \u0026ldquo;A\u0026rdquo;:\nTypeAdapterConfig\u0026lt;User, UserResponse\u0026gt;.NewConfig() .Map( dest =\u0026gt; dest.FullName, src =\u0026gt; $\u0026#34;{src.FirstName} {src.LastName}\u0026#34;, src =\u0026gt; src.FirstName.StartsWith(\u0026#34;A\u0026#34;, StringComparison.OrdinalIgnoreCase) ); Mapping Multiple Objects to One You can map multiple objects to a single destination object, such as combining a User object and a TraceId GUID into UserResponse.\nvar traceId = Guid.NewGuid(); var userResponse = (user, traceId).Adapt\u0026lt;UserResponse\u0026gt;(); Configuration:\nTypeAdapterConfig\u0026lt;(User User, Guid TraceId), UserResponse\u0026gt;.NewConfig() .Map(dest =\u0026gt; dest.TraceId, src =\u0026gt; src.TraceId) .Map(dest =\u0026gt; dest, src =\u0026gt; src.User); Updated UserResponse Model with TraceId namespace MapsterPlayground.Contracts { public record UserResponse( int Id, string FirstName, string LastName, string TraceId ); } Using AfterMapping for Post-Mapping Actions AfterMapping can be used for actions after mapping. Here, we log the mapped object to the console.\nTypeAdapterConfig\u0026lt;(User User, Guid TraceId), UserResponse\u0026gt;.NewConfig() .Map(dest =\u0026gt; dest.TraceId, src =\u0026gt; src.TraceId) .Map(dest =\u0026gt; dest, src =\u0026gt; src.User) .AfterMapping(dest =\u0026gt; Console.WriteLine(dest)); Using IValidatable Interface for Conditional Validation Mapster can perform actions like validation on destination objects implementing an interface, such as IValidatable.\npublic interface IValidatable { void Validate() { Console.WriteLine(\u0026#34;Validating...\u0026#34;); } } config.ForDestinationType\u0026lt;IValidatable\u0026gt;() .AfterMapping(dest =\u0026gt; dest.Validate()); UserResponse Implements IValidatable namespace MapsterPlayground.Contracts { public record UserResponse( int Id, string FirstName, string LastName, string TraceId ) : IValidatable; } Using the Mapper Instance for Mapping Mapster also supports using the Mapper instance to handle mapping operations, which will utilize global configurations.\nIMapper mapper = new Mapper(); var userResponse = mapper.Map\u0026lt;UserResponse\u0026gt;(user); Console.WriteLine(user); Console.WriteLine(userResponse); Conclusion Mapster provides a flexible and fast approach to object mapping in C#. Its support for custom configurations, global settings, and advanced features like conditional mapping and post-mapping actions makes it a powerful tool for projects with clean architecture or domain-driven design.\n","permalink":"http://localhost:1313/posts/clean-architecture/object-mapping-mapster/","summary":"\u003ch1 id=\"object-mapping-with-mapster\"\u003eObject Mapping with Mapster\u003c/h1\u003e\n\u003cp\u003eObject mapping is the process of transferring properties from one object to another, commonly used in modular or layered applications. This approach is particularly valuable in systems with clean architecture or domain-driven design, allowing seamless data transfer between modules or mapping request objects to data models, commands, or database entities.\u003c/p\u003e\n\u003cp\u003eWe will explore object mapping using the Mapster library in C#, a fast and flexible alternative to other mapping libraries like AutoMapper.\u003c/p\u003e","title":"Object Mapping"},{"content":"Global Error Handling in ASP.NET Core Introduction Error handling is essential in web application development to ensure that unhandled exceptions are appropriately managed and that clients receive meaningful error responses. In ASP.NET Core, global error handling can be achieved using several techniques, each with its advantages and suitable use cases. This article will guide you through primary approaches:\nError Handling Middleware Exception Filter Attribute UseExceptionHandler Middleware with Custom Error Endpoint We will also delve into using the ProblemDetails response format to provide standardized error information to clients, as recommended by RFC 7807.\nApproach 1: Error Handling Middleware Implementation The first approach involves creating custom middleware to catch exceptions that occur during the processing of HTTP requests. Here\u0026rsquo;s how you can implement it:\nCreating the Middleware using System.Net; using System.Text.Json; namespace YourApp.Api.Middleware; public class ErrorHandlingMiddleware { private readonly RequestDelegate _next; public ErrorHandlingMiddleware(RequestDelegate next) { _next = next; } public async Task Invoke(HttpContext context) { try { await _next(context); } catch (Exception ex) { await HandleExceptionAsync(context, ex); } } private static Task HandleExceptionAsync(HttpContext context, Exception exception) { var code = HttpStatusCode.InternalServerError; // 500 if unexpected var result = JsonSerializer.Serialize(new { error = \u0026#34;An error occurred while processing your request.\u0026#34; }); context.Response.ContentType = \u0026#34;application/json\u0026#34;; context.Response.StatusCode = (int)code; return context.Response.WriteAsync(result); } } Registering the Middleware In your Program.cs or Startup.cs, register the middleware:\nusing YourApp.Api.Middleware; var builder = WebApplication.CreateBuilder(args); // Configure services var app = builder.Build(); // Add the error handling middleware app.UseMiddleware\u0026lt;ErrorHandlingMiddleware\u0026gt;(); // Configure the HTTP request pipeline app.UseHttpsRedirection(); app.MapControllers(); app.Run(); How It Works The middleware wraps the next delegate in the pipeline with a try-catch block. If an exception occurs during request processing—whether before reaching the controller, during controller execution, or after—it is caught, and a generic error response is sent to the client. The middleware sets the response\u0026rsquo;s status code to 500 Internal Server Error and returns a JSON-formatted error message. This provides a unified error response, which is returning consistent error messages to the client. Example Server Response: HTTP/1.1 500 Internal Server Error Connection: close Content-Type: application/json Date: [Response Date] Server: [Server Name] Transfer-Encoding: chunked { \u0026#34;error\u0026#34;: \u0026#34;An error occurred while processing your request.\u0026#34; } It catches exceptions in:\nIn controllers or actions. In services or repositories called by controllers. In middleware registered after the Error Handling Middleware. Exceptions Not Caught:\nIn middleware components that are registered before the Error Handling Middleware will not be caught by it. After the response has begun being sent to the client, such as during response streaming, are not caught. Approach 2: Exception Filter Attribute Implementation The second approach uses an exception filter attribute that can be applied globally or to specific controllers.\nThere are two main ways to implement the exception filter:\nReturning a Simple JSON Error Response Using ProblemDetails for Detailed Error Information Returning a Simple JSON Error Response In this variant, the exception filter catches exceptions and returns a simple JSON response with an error message.\nCreating the Exception Filter:\nusing Microsoft.AspNetCore.Mvc; using Microsoft.AspNetCore.Mvc.Filters; namespace YourApp.Api.Filters; public class ErrorHandlingFilterAttribute : ExceptionFilterAttribute { public override void OnException(ExceptionContext context) { var exception = context.Exception; context.Result = new ObjectResult(new { error = \u0026#34;An error occurred while processing your request.\u0026#34; }) { StatusCode = 500 }; context.ExceptionHandled = true; } } In this code:\nThe OnException method is overridden to handle exceptions. When an exception occurs, the filter creates a new ObjectResult containing a JSON object with an error property. The status code is set to 500 Internal Server Error. context.ExceptionHandled is set to true to indicate that the exception has been handled. Example Server Response:\nHTTP/1.1 500 Internal Server Error Content-Type: application/json; Date: [Response Date] Server: [Server Name] Transfer-Encoding: chunked { \u0026#34;error\u0026#34;: \u0026#34;An error occurred while processing your request.\u0026#34; } This response provides a simple error message in JSON format, which can be easily parsed by clients.\nUsing ProblemDetails for Detailed Error Information In this variant, the exception filter uses the ProblemDetails class to return standardized error information according to RFC 7807.\nCreating the Exception Filter:\nusing System.Net; using Microsoft.AspNetCore.Mvc; using Microsoft.AspNetCore.Mvc.Filters; namespace YourApp.Api.Filters; public class ErrorHandlingFilterAttribute : ExceptionFilterAttribute { public override void OnException(ExceptionContext context) { var exception = context.Exception; var problemDetails = new ProblemDetails { Type = \u0026#34;https://tools.ietf.org/html/rfc7231#section-6.6.1\u0026#34;, Title = \u0026#34;An error occurred while processing your request.\u0026#34;, Status = (int)HttpStatusCode.InternalServerError, }; context.Result = new ObjectResult(problemDetails); context.ExceptionHandled = true; } } In this code:\nA ProblemDetails object is created to represent the error. The Type property provides a URI reference to the problem type, according to the HTTP specification. The Title and Status properties provide a human-readable summary and the HTTP status code, respectively. The ProblemDetails object is set as the result. context.ExceptionHandled is set to true to prevent the exception from propagating further. Example Server Response:\nHTTP/1.1 500 Internal Server Error Content-Type: application/problem+json; Date: [Response Date] Server: [Server Name] Transfer-Encoding: chunked { \u0026#34;type\u0026#34;: \u0026#34;https://tools.ietf.org/html/rfc7231#section-6.6.1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;An error occurred while processing your request.\u0026#34;, \u0026#34;status\u0026#34;: 500 } This response conforms to the Problem Details specification, providing standardized error information that clients can utilize for better error handling.\nApplying the Filter Globally To apply the exception filter globally, register it in your Program.cs or Startup.cs file:\nusing YourApp.Api.Filters; var builder = WebApplication.CreateBuilder(args); builder.Services.AddControllers(options =\u0026gt; { options.Filters.Add\u0026lt;ErrorHandlingFilterAttribute\u0026gt;(); }); var app = builder.Build(); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); This ensures the exception filter is applied to all controllers in the application.\nApplying the Filter to a Specific Controller You can also apply the filter to a single controller using an attribute:\n[ApiController] [Route(\u0026#34;auth\u0026#34;)] [ErrorHandlingFilter] // Exception handling filter public class AuthenticationController : ControllerBase { // Controller actions } This applies the filter only to the AuthenticationController, making it useful when you need custom exception handling for specific controllers.\nHow It Works The ErrorHandlingFilterAttribute inherits from ExceptionFilterAttribute and overrides the OnException method. When an unhandled exception occurs within a controller action, the filter intercepts it and provides a standardized error response. The flag context.ExceptionHandled = true ensures that the exception is marked as handled, preventing it from propagating further in the request pipeline. It catches exceptions in:\nController actions. Services or repositories invoked by controllers, as long as the exception is propagated back to the controller action. Exceptions Not Caught:\nExceptions that occur outside of MVC controllers (e.g., in middleware or during model binding) are not caught. This approach allows centralized error handling for controller actions, ensuring clean, consistent error responses without cluttering the controllers with exception-handling logic.\nApproach 3: UseExceptionHandler Middleware and Error Endpoint Implementation The third approach leverages the built-in UseExceptionHandler middleware, which redirects unhandled exceptions to a specified endpoint.\nConfiguring the Middleware In Program.cs or Startup.cs, configure the middleware to catch unhandled exceptions and route them to /error:\nvar builder = WebApplication.CreateBuilder(args); var app = builder.Build(); // Catches unhandled exceptions and redirects to the \u0026#34;/error\u0026#34; endpoint app.UseExceptionHandler(\u0026#34;/error\u0026#34;); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); Creating the Error Controller Create an ErrorsController to handle the errors redirected by the middleware:\nusing Microsoft.AspNetCore.Diagnostics; using Microsoft.AspNetCore.Mvc; namespace YourApp.Api.Controllers; [ApiController] [Route(\u0026#34;/error\u0026#34;)] public class ErrorsController : ControllerBase { public IActionResult HandleError() { Exception? exception = HttpContext.Features.Get\u0026lt;IExceptionHandlerFeature\u0026gt;()?.Error; return Problem(); // Returns a default ProblemDetails response (500 status) } } Example Response (500 Internal Server Error):\nHTTP/1.1 500 Internal Server Error Content-Type: application/problem+json; charset=utf-8 Date: [Response Date] Server: [Server Name] Cache-Control: no-cache, no-store Expires: -1 Pragma: no-cache Transfer-Encoding: chunked { \u0026#34;type\u0026#34;: \u0026#34;https://tools.ietf.org/html/rfc7231#section-6.6.1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;An error occurred while processing your request.\u0026#34;, \u0026#34;status\u0026#34;: 500, \u0026#34;traceId\u0026#34;: \u0026#34;[Trace ID]\u0026#34; } Customizing the Response\nYou can customize the error response with a custom title and status code:\nreturn Problem(title: exception?.Message, statusCode: 400); Example Response (400 Bad Request):\nHTTP/1.1 400 Bad Request Content-Type: application/problem+json; charset=utf-8 Date: [Response Date] Server: [Server Name] Cache-Control: no-cache, no-store Expires: -1 Pragma: no-cache Transfer-Encoding: chunked { \u0026#34;type\u0026#34;: \u0026#34;https://tools.ietf.org/html/rfc7231#section-6.5.1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;User with given email already exists.\u0026#34;, \u0026#34;status\u0026#34;: 400, \u0026#34;traceId\u0026#34;: \u0026#34;[Trace ID]\u0026#34; } This setup centralizes error handling, allowing you to customize error responses while maintaining a clean and maintainable codebase.\nUseExceptionHandler Middleware without a Custom Error Endpoint In this approach, exceptions are handled directly in a middleware extension, without a dedicated controller.\nMiddleware Extension Method\nHere\u0026rsquo;s the example of handling global errors without a custom error endpoint or manual traceId addition:\nusing Microsoft.AspNetCore.Diagnostics; public static class WebApplicationExtensions { public static WebApplication UseGlobalErrorHandling(this WebApplication app) { app.UseExceptionHandler(\u0026#34;/error\u0026#34;); app.Map(\u0026#34;/error\u0026#34;, (HttpContext httpContext) =\u0026gt; { Exception? exception = httpContext.Features.Get\u0026lt;IExceptionHandlerFeature\u0026gt;()?.Error; return Results.Problem(); }); return app; } } Registering in Program.cs\nvar builder = WebApplication.CreateBuilder(args); var app = builder.Build(); app.UseGlobalErrorHandling(); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); Example Response (500 Internal Server Error):\nThe traceId is not automatically included.\nHTTP/1.1 500 Internal Server Error Content-Type: application/problem+json; charset=utf-8 Date: [Response Date] Server: [Server Name] Cache-Control: no-cache, no-store Expires: -1 Pragma: no-cache Transfer-Encoding: chunked { \u0026#34;type\u0026#34;: \u0026#34;https://tools.ietf.org/html/rfc7231#section-6.6.1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;An error occurred while processing your request.\u0026#34;, \u0026#34;status\u0026#34;: 500 } How It Works The UseExceptionHandler middleware catches unhandled exceptions that occur after the middleware is registered in the pipeline and redirects the request to a specified endpoint (e.g., /error). The ErrorsController processes the error and returns a standardized response using the Problem() method, which constructs a ProblemDetails object compliant with RFC 7807. Exceptions Caught:\nIn controllers during the execution of actions. In services or repositories called by controllers, provided they propagate up to the controller. In middleware registered after the UseExceptionHandler middleware. Any other exceptions in the pipeline, as long as they happen after the UseExceptionHandler middleware is registered. Exceptions Not Caught:\nBefore the UseExceptionHandler middleware is registered in the pipeline. After the response has started being sent to the client (e.g., during response streaming). Using ProblemDetails for Error Responses ProblemDetails Response Format The ProblemDetails class in ASP.NET Core implements the RFC 7807 specification for error responses. It standardizes error responses with properties such as:\nType: A URI reference that identifies the problem type. Title: A short, human-readable summary of the problem type. This should remain consistent for similar errors (e.g., \u0026ldquo;Bad Request\u0026rdquo; or \u0026ldquo;Unauthorized\u0026rdquo;). Status: The HTTP status code. Detail: A human-readable explanation that is specific to this occurrence of the problem. Unlike the Title, the Detail may vary depending on the specific error (e.g., \u0026ldquo;Invalid input parameters\u0026rdquo; or \u0026ldquo;User does not have sufficient credits\u0026rdquo;). Avoid parsing information from Detail—instead, use extension fields for structured error data that the client might need to handle programmatically. Instance: A URI reference that identifies the specific occurrence of the problem. Here\u0026rsquo;s an example of a ProblemDetails response:\n{ \u0026#34;type\u0026#34;: \u0026#34;https://tools.ietf.org/html/rfc7231#section-6.5.1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Bad Request\u0026#34;, \u0026#34;status\u0026#34;: 400, \u0026#34;detail\u0026#34;: \u0026#34;Invalid input parameters.\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/api/values/5\u0026#34;, \u0026#34;traceId\u0026#34;: \u0026#34;|7ff13e2b-4dd3d7fbfb934bce.\u0026#34; } Extending ProblemDetails for Global Error Handling Customizing ProblemDetails gives developers control to add extra information like traceId, modify error messages, or include additional metadata.\nCustomizing ProblemDetails There are two main ways to customize ProblemDetails based on your .NET version:\nIn .NET 7+, you can use AddProblemDetails() to modify error responses. In earlier .NET versions, you can create a custom ProblemDetailsFactory to handle error logic. Customizing with AddProblemDetails() in .NET 7+ To enhance error responses in .NET 7+ using AddProblemDetails(), we can add extra fields to ProblemDetails or modify existing ones.\npublic static class ServiceCollectionExtensions { public static IServiceCollection AddGlobalErrorHandling(this IServiceCollection services) { services.AddProblemDetails(options =\u0026gt; { // Customize ProblemDetails to add traceId and any other fields options.CustomizeProblemDetails = context =\u0026gt; { context.ProblemDetails.Extensions[\u0026#34;traceId\u0026#34;] = context.HttpContext.TraceIdentifier; context.ProblemDetails.Extensions[\u0026#34;customField\u0026#34;] = \u0026#34;CustomValue\u0026#34;; // Additional custom field }; }); return services; } } In this example, the CustomizeProblemDetails delegate is used to add custom information to every error response, such as a traceId, or any other custom fields that you want to include in your API responses.\nRegistering Global Error Handling in Program.cs\nvar builder = WebApplication.CreateBuilder(args); // Add global error handling with ProblemDetails customization builder.Services.AddGlobalErrorHandling(); var app = builder.Build(); // Ensure exceptions are caught and redirected to the error endpoint app.UseExceptionHandler(\u0026#34;/error\u0026#34;); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); Example of Custom Response\nHere’s an example of what an error response might look like with the added traceId and custom field:\nHTTP/1.1 500 Internal Server Error Content-Type: application/problem+json; charset=utf-8 Date: [Response Date] Server: [Server Name] Cache-Control: no-cache, no-store Expires: -1 Pragma: no-cache Transfer-Encoding: chunked { \u0026#34;type\u0026#34;: \u0026#34;https://tools.ietf.org/html/rfc7231#section-6.6.1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;An error occurred while processing your request.\u0026#34;, \u0026#34;status\u0026#34;: 500, \u0026#34;traceId\u0026#34;: \u0026#34;[Trace ID]\u0026#34;, \u0026#34;customField\u0026#34;: \u0026#34;CustomValue\u0026#34; } Customizing with ProblemDetailsFactory in Earlier .NET Versions In .NET versions earlier than 7, the same functionality can be achieved by implementing a custom ProblemDetailsFactory.\nusing System.Diagnostics; using Microsoft.AspNetCore.Mvc; using Microsoft.AspNetCore.Mvc.Infrastructure; using Microsoft.AspNetCore.Mvc.ModelBinding; using Microsoft.Extensions.Options; namespace YourApp.Api.Errors; public class CustomProblemDetailsFactory : ProblemDetailsFactory { private readonly ApiBehaviorOptions _options; public CustomProblemDetailsFactory(IOptions\u0026lt;ApiBehaviorOptions\u0026gt; options) { _options = options?.Value ?? throw new ArgumentNullException(nameof(options)); } public override ProblemDetails CreateProblemDetails( HttpContext httpContext, int? statusCode = null, string? title = null, string? type = null, string? detail = null, string? instance = null) { statusCode ??= 500; var problemDetails = new ProblemDetails { Status = statusCode, Title = title ?? \u0026#34;An error occurred while processing your request.\u0026#34;, Type = type, Detail = detail, Instance = instance, }; ApplyProblemDetailsDefaults(httpContext, problemDetails, statusCode.Value); return problemDetails; } public override ValidationProblemDetails CreateValidationProblemDetails( HttpContext httpContext, ModelStateDictionary modelStateDictionary, int? statusCode = null, string? title = null, string? type = null, string? detail = null, string? instance = null) { statusCode ??= 400; var problemDetails = new ValidationProblemDetails(modelStateDictionary) { Status = statusCode, Title = title ?? \u0026#34;One or more validation errors occurred.\u0026#34;, Type = type, Detail = detail, Instance = instance, }; ApplyProblemDetailsDefaults(httpContext, problemDetails, statusCode.Value); return problemDetails; } private void ApplyProblemDetailsDefaults(HttpContext httpContext, ProblemDetails problemDetails, int statusCode) { problemDetails.Status ??= statusCode; if (_options.ClientErrorMapping.TryGetValue(statusCode, out var clientErrorData)) { problemDetails.Title ??= clientErrorData.Title; problemDetails.Type ??= clientErrorData.Link; } var traceId = Activity.Current?.Id ?? httpContext?.TraceIdentifier; if (traceId != null) { problemDetails.Extensions[\u0026#34;traceId\u0026#34;] = traceId; } // Add custom properties problemDetails.Extensions.Add(\u0026#34;customProperty\u0026#34;, \u0026#34;customValue\u0026#34;); } } Registering the Custom Factory\nIn Program.cs, register this custom factory as a service:\nvar builder = WebApplication.CreateBuilder(args); // Register the custom ProblemDetailsFactory builder.Services.AddSingleton\u0026lt;ProblemDetailsFactory, CustomProblemDetailsFactory\u0026gt;(); var app = builder.Build(); app.UseExceptionHandler(\u0026#34;/error\u0026#34;); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); Example of Custom Response with Custom Factory\nHere’s a similar error response with custom data from the ProblemDetailsFactory:\nHTTP/1.1 500 Internal Server Error Content-Type: application/problem+json; charset=utf-8 Date: [Response Date] Server: [Server Name] Cache-Control: no-cache, no-store Expires: -1 Pragma: no-cache Transfer-Encoding: chunked { \u0026#34;type\u0026#34;: \u0026#34;https://tools.ietf.org/html/rfc7231#section-6.6.1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;An error occurred.\u0026#34;, \u0026#34;status\u0026#34;: 500, \u0026#34;traceId\u0026#34;: \u0026#34;[Trace ID]\u0026#34;, \u0026#34;customProperty\u0026#34;: \u0026#34;customValue\u0026#34; } Wrap-up By customizing ProblemDetails, you can provide detailed and useful error responses in a standardized format, allowing better error handling for clients. With .NET 7+, this process is made easier through AddProblemDetails(), while earlier versions require a custom ProblemDetailsFactory for similar functionality. In both cases, you can ensure that error responses are consistent, informative, and secure.\nConclusion Global error handling in ASP.NET Core can be achieved through various methods, each with its own advantages. By using middleware, exception filters, or the built-in UseExceptionHandler middleware, you can catch exceptions and provide consistent, meaningful responses to clients. Leveraging the ProblemDetails response format helps standardize error responses and improves client-side error handling.\nMethod Exceptions in Controllers Exceptions in Services or Repositories Exceptions in Middleware Registered After Exceptions in Middleware Registered Before Exceptions After Response Sent Error Handling Middleware Yes Yes Yes No No Exception Filter Attribute Yes Yes No No No UseExceptionHandler Middleware Yes Yes Yes No No Remark While these approaches centralize exception handling, proper error flow management is crucial. Simply allowing exceptions to bubble up will result in a generic 500 response. Services, like a review service, should handle errors correctly to provide meaningful responses instead of unnecessary exceptions.\n","permalink":"http://localhost:1313/posts/clean-architecture/global-error-handling/","summary":"\u003ch1 id=\"global-error-handling-in-aspnet-core\"\u003eGlobal Error Handling in ASP.NET Core\u003c/h1\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eError handling is essential in web application development to ensure that unhandled exceptions are appropriately managed and that clients receive meaningful error responses. In ASP.NET Core, global error handling can be achieved using several techniques, each with its advantages and suitable use cases. This article will guide you through primary approaches:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eError Handling Middleware\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eException Filter Attribute\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUseExceptionHandler Middleware with Custom Error Endpoint\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWe will also delve into using the \u003ccode\u003eProblemDetails\u003c/code\u003e response format to provide standardized error information to clients, as recommended by RFC 7807.\u003c/p\u003e","title":"Global Error Handling"},{"content":"Introduction to Clean Architecture Software Architecture Software architecture defines the structure of a system, its components, their relationships, and design principles to ensure the system meets its functional and non-functional needs.\nKey Concepts Components The building blocks of the system, including services, modules, and databases.\nRelationships Defines how components communicate and interact with each other.\nDesign Principles Guidelines that ensure the system is scalable, maintainable, and secure.\nArchitectural Patterns The overall structure used, such as microservices, layered architecture, etc.\nTechnology Stack The programming languages, frameworks, and tools used to build the system.\nArchitecture Pattern: Architecture Pattern is a general, reusable resolution to a commonly occurring problem in software architecture within a given context.\nExamples of Architecture Patterns: Architecture Pattern Description Focus Area N-tier/Layered Architecture Organizes software into layers, each responsible for a specific aspect (e.g., presentation, business logic, data access). Separation of concerns across layers Layered Architecture Flow The diagram represents the flow in an N-tier architecture where:\nThe Presentation Layer interacts with the Business Logic Layer. The Business Logic Layer communicates with the Data Access Layer. The Data Access Layer accesses the Database (DB). Each layer is visually distinct, demonstrating the separation of concerns in a typical multi-tier architecture.\nArchitectural Issues In this architecture, a presentation layer directly accesses the data repository, as shown in the following code:\n// Tier N-2 (e.g., Presentation Layer) var user = _userRepository.GetById(userId); // Tier N (Data Access Layer) public interface IUserRepository { User GetById(Guid id); } Transitive Layer Access - layers become dependent on each other, making the system harder to maintain and scale.\nHexagonal/Ports and Adapters Architecture Focuses on keeping the core logic independent of external factors (e.g., databases, UI, APIs). Independence from external systems Microservices Architecture Structures applications as a collection of loosely coupled, independently deployable services. Decoupling and scalability Clean Architecture Emphasizes separating concerns and keeping core logic independent of infrastructure and frameworks. Independence of core logic Clean Architecture Clean architecture separates the software into layers with a dependency rule that layers only point inwards.\nInner layers contain the business logic. Outer layers contain infrastructure and interaction with the outer world. This structure helps maintain a clear separation of concerns and ensures that the core business logic is independent of external systems or user interface concerns.\nProject Setup Script This script automates the creation of a .NET solution with multiple projects following a clean architecture pattern.\n#!/bin/bash # Check if the required arguments are provided if [ $# -ne 2 ]; then echo \u0026#34;Usage: $0 \u0026lt;SolutionName\u0026gt; \u0026lt;ProjectName\u0026gt;\u0026#34; exit 1 fi # Assign arguments to variables SOLUTION_NAME=$1 PROJECT_NAME=$2 # Create the solution with the given SolutionName dotnet new sln --name \u0026#34;$SOLUTION_NAME\u0026#34; # Create WebAPI project with the given ProjectName dotnet new webapi -o \u0026#34;$PROJECT_NAME.Api\u0026#34; # Create class libraries for Application, Infrastructure, and Domain layers dotnet new classlib -o \u0026#34;$PROJECT_NAME.Application\u0026#34; dotnet new classlib -o \u0026#34;$PROJECT_NAME.Infrastructure\u0026#34; dotnet new classlib -o \u0026#34;$PROJECT_NAME.Domain\u0026#34; # Add projects to the solution dotnet sln add \u0026#34;$PROJECT_NAME.Api/$PROJECT_NAME.Api.csproj\u0026#34; dotnet sln add \u0026#34;$PROJECT_NAME.Application/$PROJECT_NAME.Application.csproj\u0026#34; dotnet sln add \u0026#34;$PROJECT_NAME.Infrastructure/$PROJECT_NAME.Infrastructure.csproj\u0026#34; dotnet sln add \u0026#34;$PROJECT_NAME.Domain/$PROJECT_NAME.Domain.csproj\u0026#34; # Add references between projects dotnet add \u0026#34;$PROJECT_NAME.Api\u0026#34; reference \u0026#34;$PROJECT_NAME.Application\u0026#34; dotnet add \u0026#34;$PROJECT_NAME.Infrastructure\u0026#34; reference \u0026#34;$PROJECT_NAME.Application\u0026#34; dotnet add \u0026#34;$PROJECT_NAME.Application\u0026#34; reference \u0026#34;$PROJECT_NAME.Domain\u0026#34; # Build the solution to verify everything is set up correctly dotnet build Run the script with the following arguments:\n./script.sh \u0026lt;SolutionName\u0026gt; \u0026lt;ProjectName\u0026gt; Service-Oriented Architecture (SOA) Breaks down systems into services that communicate over a network. Distributed services over a network Modular Monolith Architecture Combines modular components within a single deployable unit, allowing easier refactoring and scaling. Modularity within a single unit Event-Driven Architecture Uses events as triggers for communication between decoupled components or services. Asynchronous event handling MVC, MVP, MVVM Patterns for organizing the presentation layer in software, separating concerns between the model (data), view (UI), and controller/presenter (logic). Presentation layer organization ","permalink":"http://localhost:1313/posts/clean-architecture/introduction/","summary":"\u003ch1 id=\"introduction-to-clean-architecture\"\u003eIntroduction to Clean Architecture\u003c/h1\u003e\n\u003ch2 id=\"software-architecture\"\u003eSoftware Architecture\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eSoftware architecture\u003c/strong\u003e defines the structure of a system, its components, their relationships, and design principles to ensure the system meets its functional and non-functional needs.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"key-concepts\"\u003eKey Concepts\u003c/h3\u003e\n\u003cdetails\u003e\n  \u003csummary\u003e\u003cstrong\u003eComponents\u003c/strong\u003e\u003c/summary\u003e\n  \u003cp\u003eThe building blocks of the system, including services, modules, and databases.\u003c/p\u003e\n\u003c/details\u003e\n\u003cdetails\u003e\n  \u003csummary\u003e\u003cstrong\u003eRelationships\u003c/strong\u003e\u003c/summary\u003e\n  \u003cp\u003eDefines how components communicate and interact with each other.\u003c/p\u003e\n\u003c/details\u003e\n\u003cdetails\u003e\n  \u003csummary\u003e\u003cstrong\u003eDesign Principles\u003c/strong\u003e\u003c/summary\u003e\n  \u003cp\u003eGuidelines that ensure the system is scalable, maintainable, and secure.\u003c/p\u003e\n\u003c/details\u003e\n\u003cdetails\u003e\n  \u003csummary\u003e\u003cstrong\u003eArchitectural Patterns\u003c/strong\u003e\u003c/summary\u003e\n  \u003cp\u003eThe overall structure used, such as microservices, layered architecture, etc.\u003c/p\u003e","title":"Introduction to Clean Architecture"},{"content":"Test github actions.\n","permalink":"http://localhost:1313/about_me/","summary":"\u003cp\u003eTest github actions.\u003c/p\u003e","title":"About me"}]